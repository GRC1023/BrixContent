var util             = require("util")
  , http            = require("http")
  , querystring     = require("querystring")
  , util            = require("util")
  , request         = require("request")
  , cmac            = require("./aes128")
  , _               = require("underscore");


// ## Prospero module configuration
//
// Expects config object
//
//      config: {
//        prosperoDefaults: {
//          ...
//        },
//        sharedKey: "",
//        principal: "",
//        rootUrl: "http://host:port"
//    }
//
// The prosperoConfig object is used
// to configure defaults when publishing. For example for
// properties like Properties like <code>client</code>,
// <code>clientString</code>, <code>system</code>, <code>subSystem</code>
//
//                    The corresponding properties
//                    that Prospero expects
//                                    |
//                                    ↓
//      obj: {
//        tags: { UserID: "joe" },  // name value pairs --> TAGS
//        client: '',               // CLIENT
//        clientString: '',         // CLIENT-STRING
//        system: '',               // SYSTEM
//        subSystem: '',            // SUB-SYSTEM
//        realm: '',                // REALM
//        payloadContentType: '',   // PAYLOAD-CONTENT-TYPE
//    }
//
// SYNCHRONOUS
module.exports = function(config) {

  var that = this;

  this.config = {
    sharedKey: config.sharedKey,
    principal: config.principal,
    rootUrl: config.rootUrl,
    prosperoDefaults:
      _.extend({
          client: "",
          clientString: "",
          system: "",
          subSystem: "",
          realm: "*",
          payloadContentType: "application/json"
      }, config.prosperoDefaults)
  }


// ## Publish a new message to Prospero.
//
// Expects object for message to publish
//
// The object passed to publish will be merged with the prosperoDefaults
// object specified in the config. Any properties that are passed in here
// will override the value in the defaults. Properties like <code>client</code>,
// <code>clientString</code>, <code>system</code>, <code>subSystem</code> would be more appropriate to
// set up as a default in the prosperoDefaults config.
//
//                    The corresponding properties
//                    that Prospero expects
//                                    |
//                                    ↓
//      obj: {
//        tags: { UserID: "joe" },  // name value pairs --> TAGS
//        client: '',               // CLIENT
//        clientString: '',         // CLIENT-STRING
//        system: '',               // SYSTEM
//        subSystem: '',            // SUB-SYSTEM
//        realm: '',                // REALM
//        messageType: '',          // MESSAGE-TYPE
//        payloadContentType: '',   // PAYLOAD-CONTENT-TYPE
//        payload: ''               // PAYLOAD
//    }
//
// The callback takes two parameters:
//  <code>error</code>: Error object in case of an error
//  <code>result</code>: Object with two properties: <code>statusCode</code> and <code>data</code>
//
  this.publish = function(obj, callback) {

    if(obj.payloadContentType === 'application/json' && typeof obj.payload === 'object')
      obj.payload = JSON.stringify(obj.payload);

    obj = _.extend(that.config.prosperoDefaults, obj);

    var tags = that._parseTags(obj.tags);
  	var authData = obj.client + obj.clientString + obj.system + obj.subSystem + obj.realm + tags + obj.messageType + obj.payloadContentType + obj.payload;
  	var authToken = that._getAuthToken(authData);
  	var postBody  = querystring.stringify({
  	    "TAGS": tags,
  	    "CLIENT": obj.client,
  	    "CLIENT-STRING": obj.clientString,
  	    "SYSTEM": obj.system,
  	    "SUB-SYSTEM": obj.subSystem,
  	    "REALM": obj.realm,
  	    "MESSAGE-TYPE": obj.messageType,
  	    "PAYLOAD-CONTENT-TYPE": obj.payloadContentType,
  	    "PAYLOAD": obj.payload,
  	    "AUTHORIZATION": authToken
  	});

    request({
      uri: that.config.rootUrl + '/v1/message',
      method: 'POST',
      headers: { 'content-type': 'application/x-www-form-urlencoded' },
      body: postBody
    }, function (error, response, body) {

      if(response.statusCode !== 200 && !error)
          error = new Error("Unexpected HTTP Status " + response.statusCode);

      if(response.headers['content-type'] === 'application/json') {
        try {
          body = JSON.parse(body);
        }
        catch (err) {
          error = new Error("Failed to parse expected JSON: " + prosperoData);
        }
      }

      var result = {
        statusCode: response.statusCode,
        data: body
      };
      callback(error, result);

    });

  };


// ## Subscribe to message types
//
// Subscribe to a given message type, specifying a callback URL
// for the webhook destination where Prospero should attempt to
// POST messages, optionally specifying tag key value pairs
//
// <code>obj</code> should contain:
//
//      obj: {
//        messageType: '',        // MESSAGE-TYPE
//        callbackUrl: '',        // CALLBACK-URL
//        tags: { UserID: 'joe' } // TAGS
//    }
//
// The callback takes two parameters:
//  <code>error</code>: Error object in case of an error
//  <code>result</code>: Object with two properties: <code>statusCode</code> and <code>data</code>
  this.subscribe = function(obj, callback) {
  	var tags = that._parseTags(obj.tags);
  	var authData = obj.callbackUrl + tags + obj.messageType;
  	var authToken = that._getAuthToken(authData);

  	var postBody  = querystring.stringify({
  	    "TAGS": tags,
  	    "MESSAGE-TYPE": obj.messageType,
  	    "CALLBACK-URL": obj.callbackUrl,
  	    "AUTHORIZATION": authToken
  	});

    request({
      uri: that.config.rootUrl + '/v1/subscription',
      method: 'POST',
      headers: { 'content-type': 'application/x-www-form-urlencoded' },
      body: postBody
    }, function (error, response, body) {

      if (error) {
        callback(error, null);
	return;
      }

      // if this is a duplication subscription, get the details of that
      // subscription
      if(response.statusCode === 409) {
        var subId = response.headers['x-prospero-subscription-id'];
        return that.getSubscription(subId, callback);
      }

      if(response.headers['content-type'] === 'application/json') {
        try {
          body = JSON.parse(body);
        }
        catch (err) {
          error = error || new Error("Failed to parse expected JSON: " + prosperoData);
        }
      }

      var result = {
        statusCode: response.statusCode,
        data: body
      };
      callback(error, result);
    });
  };

// ## Get subscription details
//
// subId - string: the Prospero subscription Id
//
// The callback takes two parameters:
//  <code>error</code>: Error object in case of an error
//  <code>result</code>: Object with two properties: <code>statusCode</code> and <code>data</code>
  this.getSubscription = function(subId, callback) {
    var authData = subId,
        authToken = that._getAuthToken(authData),
        headers = {
          'Authorization': authToken
        };

    request({
      uri: that.config.rootUrl + '/v1/subscription/' + subId,
      headers: headers
    }, function (error, response, body) {
      if(response.headers['content-type'] === 'application/json') {
        try {
          body = JSON.parse(body);
        }
        catch (err) {
          error = error || new Error("Failed to parse expected JSON: " + prosperoData);
        }
      }

      var result = {
        statusCode: response.statusCode,
        data: body
      };
      callback(error, result);
    });
  }


// ## Unsubscribe to a subscription by subscription Id
//
// subId - string: the Prospero subscription Id
//
// The callback takes two parameters:
//  <code>error</code>: Error object in case of an error
//  <code>result</code>: Object with two properties: <code>statusCode</code> and <code>data</code>
  this.unsubscribe = function(subId, callback) {
    var authData = subId,
        authToken = that._getAuthToken(authData),
        headers = {
          'Authorization': authToken
        };

    request({
      uri: that.config.rootUrl + '/v1/subscription/' + subId,
      headers: headers,
      method: 'DELETE'
    }, function (error, response, body) {

      if(response.headers['content-type'] === 'application/json') {
        try {
          body = JSON.parse(body);
        }
        catch (err) {
          error = error || new Error("Failed to parse expected JSON: " + prosperoData);
        }
      }

      var result = {
        statusCode: response.statusCode,
        data: body
      };
      callback(error, result);
    });
  };


// ## Receive a Prospero Message
//
// Receive a message from a subscription callback
//
// Assume the client of this library has an HTTP listener and expects prospero
// messages at some URI (that they probably create a subscription for)
// If they get a request that they want considered as a prospero message, they would
// call this function passing the request, response and  a callback
//
// req - a HTTP Request
// res - the HTTP Response object
// callback - function(error, data, done(success, [message]))
//
// The callback should first take an <code>error</code> parameter. This value will be 'truthy'
// if there was an error. You can expect it to be a proper <code>Error</code> object.
//
// The callback's second parameter <code>data</code> is the payload of the received message.
// If the payload content type is <code>application/json</code> this will be automatically
// parsed for you so expect an <code>object</code> rather than a <code>string</code>
//
// The callback should expect a <code>done(success, [message])</code> function as a 3rd parameter.
// This function needs to be called when you are finished processing the prospero message.
// If you have successfully processed the message you can either call done with no parameters
// or with a boolean <code>true</code>
//
//      done();
//      done(true);
//      done(true, "A message that will be returned to prospero");
//
// Otherwise, if you want to reject the message from Prospero, telling Prospero to attempt to
// redeliver in the future, you should call done but with a boolean <code>false</code>:
//
//      done(false);
//      done(false, "My dog ate the message before I could process it!");
  this.receive = function(req, res, callback) {

    /* if the body has been parsed already by some connect style middleware */
    /* and req.body exists, assume it's already been parse, otherwise parse it */
    if(req.body)
      receiveMessage(req.body);
    else
      that._parsePostBody(req, receiveMessage);

    function receiveMessage(data) {
      if (!that._isValidProsperoMessage(data))
        return callback(new Error("Prospero message is invalid"), null, done);

      if (data['PAYLOAD-CONTENT-TYPE'] === 'application/json') {
        try {
          data['JSON-PAYLOAD'] = JSON.parse(data.PAYLOAD);
        } catch (err) {
          util.log("Failed to parse JSON in message " + util.inspect(data) + " - " + err);
        }
      }

      callback(null, data, done);
    }

    function done(success, message) {
      if(success === undefined) success = true;
      res.statusCode = (success) ? 200 : 503;
      if(message !== undefined) {
        res.setHeader("Content-Type", "text/plain");
        res.end(message);
      } else {
        res.end();
      }
    }
  };

//
// Conveinence function for formatting IO 8601 Zulu timestamps. Best practice
// is that all date/time representations send through Prospero should use
// this timestamp format.
//
// SYNCHRONOUS
// @return {String} formatted ISO 8601 timestampe like 2011-04-01T20:21:07Z
//
  this.formatTimestamp = function(date) {
    return cmac.formatTimestamp(date);
  }


//
// helper to parse an object of tags and return a comma delimited string like
// tagsObj : { "1":"a", "2":"c", "3":"c"} --> "1:a,2:c,3:c"
//
// SYNCHRONOUS
// @return tag string
//
  this._parseTags = function(tagsObj) {
    var tags = [];
    tagsObj = tagsObj || {};
    _.each(_.keys(tagsObj), function(key) {
      tags.push(key + ":" + tagsObj[key]);
    });
    return tags.join(",");
  };

//
// Given a request, parse out the POST body and pass it to the callback with
// a data argument callback(data)
//
  this._parsePostBody = function(req, callback) {
    var postBody = {};
    var content = "";

    if (req.method == "POST") {
      req.addListener('data', function(chunk) {
        content += chunk;
      });

      req.addListener('end', function() {
        try {
          postBody = querystring.parse(content);
          callback(postBody);
        } catch (e) {
          callback(postBody);
        }
      });
    }
  };

//
// Sample Prospero Message:
//
//    { 'DELIVERY-ATTEMPT-ID': '7e1298db-3fae-4316-ac54-ae561e79d01a',
//      'MESSAGE-TYPE': 'Browser.Activity',
//      'MESSAGE-ID': '610e556b-fad9-4a99-b707-8adfb94042c5',
//      AUTHORIZATION: 'ONE|2011-04-01T20:21:07Z|6152692d8176532b42333796f4727c8e',
//      'AUTHORIZATION-DELIMITER': '|',
//      PAYLOAD: '{"activity":{"name":"connected","user_agent":"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_6; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16","user_agent_browser":"Chrome 10.0.648","user_agent_os":"OS X 10.6.6","flash_version":"10,2,154","referrer":"https://localhost:3000/test/index.html","browser_channel_transport":"websocket","served_from_host":"https://localhost:3000","page_id":"A146D7E5-320E-408F-9901-2ECFCF024218","ms_since_page_load":"26","datetime":"2011-04-01T20:21:07.710Z"}}',
//      'PAYLOAD-CONTENT-TYPE': 'application/json' }
//
// SYNCHRONOUS
//
  this._isValidProsperoMessage = function(message) {
    var messageDataString = message["MESSAGE-ID"] + message["MESSAGE-TYPE"] + message["PAYLOAD-CONTENT-TYPE"] + message["PAYLOAD"],
        authorization = message["AUTHORIZATION"] ? message["AUTHORIZATION"].split(message["AUTHORIZATION-DELIMITER"]) : null,
        timestamp = authorization ? authorization[1] : null;

    try {
      calculatedAuthToken = that._getAuthToken(messageDataString, timestamp);
    } catch (err) {
      util.log(err);
    }

    return calculatedAuthToken === message["AUTHORIZATION"];
  }

//
// helper to create an authToken from a string of concatenated data
//
// SYNCHRONOUS
// @return authToken like 'ONE|2011-04-01T20:21:07Z|6152692d8176532b42333796f4727c8e'
  this._getAuthToken = function(data, timestamp) {
    timestamp = timestamp || cmac.formatTimestamp();
    var cmacToken = cmac.cmac(that.config.sharedKey, timestamp + data);
    return that.config.principal + "|" + timestamp + "|" + cmacToken;
  };

};

