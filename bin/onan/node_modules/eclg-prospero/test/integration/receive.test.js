var assert = require('assert');
var querystring = require('querystring');
var http = require('http');
var Prospero = require('../../lib/prospero');

var sharedConfig = {
    rootUrl: 'http://localhost:4778',
    principal: "ONE",
    sharedKey: "1234567890123456",
    prosperoDefaults: {
       client: 'Node-Test',
       clientString: 'client.string',
       system: 'Node-Test',
       subSystem: 'Node-Test',
       realm: 'foo'
    }
};

var testServerPort = 18990;


exports['test subscribe, publish and receive'] = function(){
    var subObj = {
        messageType: "Node.Prospero.Test3",
        callbackUrl: "http://localhost:" + testServerPort + "/test",
        tags: { UserID: "joe" }  
    };

    var pubObj = {
       tags: { UserID: "joe" },  
       messageType: 'Node.Prospero.Test3',
       payloadContentType: 'application/json',
       payload: {
            feeling: 'happy'
       }
   } 

    var p = new Prospero(sharedConfig);
    var subId = null;
    var messageId = null;

    // the server that will receive the message from the simulated Prospero
    var server = require('http').createServer(function (req, res) {
        p.receive(req, res, callback);
    });
    server.listen(testServerPort);

    var wasNextCalled = false;
    
    var finish = function() {
        server.close();
        clearTimeout(timeout);
        unsubscribe(subId);
        assert.ok(wasNextCalled);
    }

    var timeout = setTimeout(function() {
        finish();
    }, 2000);    

    var callback = function(error, data, done) {
        assert.ok(!error);
        assert.equal(messageId, data['MESSAGE-ID']);
        wasNextCalled = true;
        done();
        finish();
    };   

    function unsubscribe(subId) {
        p.unsubscribe(subId, function(error, data) {
            assert.ok(!error);
            assert.equal(200, data.statusCode)

            p.getSubscription(subId, function(error, data) {
                assert.ok(!error);
                assert.equal(404, data.statusCode);
                console.log("should be successful, exiting");
                process.exit();
            })
        });

    }

    p.subscribe(subObj, function(error, data) {
        assert.ok(!error);
        assert.ok(data.data.subscription.id);
        assert.equal(data.statusCode, 200);
        subId = data.data.subscription.id;

        // try to subscribe again
        p.publish(pubObj, function(error, data) {
            assert.ok(!error);
            assert.equal(data.statusCode, 200);
            assert.ok(data.data.message.id);
            messageId = data.data.message.id;
        });
    });    
};
